<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>rltos_task_list.c</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
/**
 * @addtogroup Rltos_task_list_prv prv
 * The private data (implementation) of the RLTOS task list.
 * @ingroup Rltos_task_list
 * @{
 */

#include "rltos.h"
#include "rltos_task_list.h"

/** @struct task_ctl_t
 * @brief Definition of task control structure
 * 
 * Contains the definition of a tasks control structure within RLTOS.
 */
struct task_ctl_t
{
	/* Task specific data*/
	stack_ptr_type stored_sp;	/**&lt; Stored value of the stack pointer*/
	void (*p_task_func)(void);	/**&lt; Function pointer for entry of point of task*/
	rltos_uint idle_ready_time; /**&lt; Value representing the time this task will be ready*/
	rltos_uint idle_time;		/**&lt; Value representing the max time this task should remain idled*/
	rltos_uint idle_wrap_count; /**&lt; Value to detect when wrap around is required*/
	rltos_uint priority;		/**&lt; Value representing the tasks priority*/

	/* List specific data*/
	struct task_ctl_t *p_next_tctl[2]; /**&lt; Pointer to the next item - can exist in two lists at once*/
	struct task_ctl_t *p_prev_tctl[2]; /**&lt; Pointer to the previous item - can exist in two lists at once*/
	p_task_list_t p_owners[2];		   /**&lt; Pointer to the list who owns this task - can exist in two lists at once*/
	rltos_uint sorting_values[2];		/**&lt; Array to store the lists sorting values*/
};

/** @struct task_list_t
 * @brief Definition of task list control structure
 * 
 * Contains the definition of a task list control structure within RLTOS.
 */
struct task_list_t
{
	p_task_ctl_t p_head;  /**&lt; Head of list*/
	p_task_ctl_t p_index; /**&lt; current index of list*/
	rltos_uint size;	  /**&lt; Size of list*/
};

/** List containing all running taks*/
static struct task_list_t running_task_list = {
	.p_head = NULL,
	.p_index = NULL,
	.size = 0U};

/** List containing all idle/blocked tasks*/
static struct task_list_t idle_task_list = {
	.p_head = NULL,
	.p_index = NULL,
	.size = 0U};

/** Pointer to current running task*/
/* cppcheck-suppress misra-c2012-8.4 - this variable is externed/declared in assembly file for porting the scheduler*/
p_task_ctl_t p_current_task_ctl = NULL;

/** Rltos system tick counter*/
static volatile rltos_uint rltos_system_tick = 0U;
/** Rltos wrap around tracker*/
static volatile rltos_uint rltos_wrap_count = 0U;
/** Rltos next time to remove task from idle list*/
static rltos_uint rltos_next_idle_ready_tick = RLTOS_UINT_MAX;
/** Rltos wrap next idle tasks wrap around tracker*/
static rltos_uint rltos_next_idle_ready_wrap_count = 0U;
/** Rltos next time to remove task from idle list*/
static bool should_switch_task = true;

/** @brief Function used to insert a task in a sorted task list
 * @param[inout] list_for_append - pointer to a task list for which the task should be inserted.
 * @param[inout] task_to_append - task to insert in list.
 * @param[in] list_index - index of the list to in which to insert the task.
 * @param[in] sorting_value - value used to sort list order.
 */
static void Task_insert_in_list(p_task_list_t const list_for_insert, p_task_ctl_t const task_to_insert, const list_index_t list_index, const rltos_uint sorting_value);

/** @brief Function used to append task to a task list
 * @param[inout] list_for_append - pointer to a task list for which the task should be appended.
 * @param[inout] task_to_append - task to append to list.
 * @param[in] list_index - index of the list to in which to append the task.
 */
static void Task_append_to_list(p_task_list_t const list_for_append, p_task_ctl_t const task_to_append, const list_index_t list_index);

/** @brief Function used to remove task from a task list
 * @param[inout] list_for_remove - pointer to a task list from which the task should be removed.
 * @param[inout] task_to_remove - task to remove from list.
 * @param[in] list_index - index of the list to in which to remove the task.
 */
static void Task_remove_from_list(p_task_list_t const list_for_remove, p_task_ctl_t const task_to_remove, const list_index_t list_index);

void Scheduler_init(void)
<span style = "background-color:#fdd">{</span>
	/* Scheduler initialisation consists of setting the pointer to the current operating task*/
<span style = "background-color:#fdd">	p_current_task_ctl = running_task_list.p_head;
}</span>
/* END OF FUNCTION*/

void Task_init(p_task_ctl_t const task_to_init, const stack_ptr_type init_sp, void (*const init_task_func)(void), rltos_uint priority, bool task_is_running)
<span style = "background-color:#dfd">{</span>
	/* Set the task function and stack pointer - then NULL init the list parameters*/
<span style = "background-color:#dfd">	task_to_init-&gt;p_task_func = init_task_func;
	task_to_init-&gt;stored_sp = init_sp;
	task_to_init-&gt;p_next_tctl[state_list] = NULL;
	task_to_init-&gt;p_next_tctl[aux_list] = NULL;
	task_to_init-&gt;p_prev_tctl[state_list] = NULL;
	task_to_init-&gt;p_prev_tctl[aux_list] = NULL;
	task_to_init-&gt;p_owners[state_list] = NULL;
	task_to_init-&gt;p_owners[aux_list] = NULL;</span>

<span style = "background-color:#dfd">	task_to_init-&gt;priority = priority;
	task_to_init-&gt;idle_ready_time = RLTOS_UINT_MAX;
	task_to_init-&gt;idle_time = RLTOS_UINT_MAX;
	task_to_init-&gt;idle_wrap_count = 0U;</span>

	/* Set the state list ownership*/
<span style = "background-color:#dfd">	if (task_is_running)</span>
	{
<span style = "background-color:#dfd">		Task_insert_in_list(&amp;running_task_list, task_to_init, state_list, task_to_init-&gt;priority);
	}</span>
	else
	{
<span style = "background-color:#fdd">		Task_insert_in_list(&amp;idle_task_list, task_to_init, state_list, task_to_init-&gt;idle_time);</span>
	}
<span style = "background-color:#dfd">}</span>
/* END OF FUNCTION*/

void Task_deinit(p_task_ctl_t const task_to_deinit)
<span style = "background-color:#dfd">{</span>
	/* Set the task function and stack pointer - then NULL init the list parameters*/
<span style = "background-color:#dfd">	task_to_deinit-&gt;p_task_func = NULL;
	task_to_deinit-&gt;stored_sp = NULL;</span>
	/* Task always exists in a state list - no need to check for NULL*/
<span style = "background-color:#dfd">	Task_remove_from_list(task_to_deinit-&gt;p_owners[state_list], task_to_deinit, state_list);</span>

	/* Aux task will be NULL if not in one*/
<span style = "background-color:#dfd">	if (NULL != task_to_deinit-&gt;p_owners[aux_list])</span>
	{
<span style = "background-color:#fdd">		Task_remove_from_list(task_to_deinit-&gt;p_owners[aux_list], task_to_deinit, aux_list);</span>
	}
<span style = "background-color:#dfd">}</span>
/* END OF FUNCTION*/

void Task_list_init(p_task_list_t const list_to_init)
<span style = "background-color:#dfd">{
	list_to_init-&gt;size = 0U;
	list_to_init-&gt;p_head = NULL;
	list_to_init-&gt;p_index = NULL;
}</span>
/* END OF FUNCTION*/

void Task_set_running(p_task_ctl_t const task_to_run)
<span style = "background-color:#fdd">{</span>
	/* If we are owned by an object -&gt; remove from objects list*/
<span style = "background-color:#fdd">	if (NULL != task_to_run-&gt;p_owners[aux_list])</span>
	{
<span style = "background-color:#fdd">		Task_remove_from_list(task_to_run-&gt;p_owners[aux_list], task_to_run, aux_list);</span>
	}

	/* Move task from idle state to running state*/
<span style = "background-color:#fdd">	Task_remove_from_list(&amp;idle_task_list, task_to_run, state_list);
	Task_insert_in_list(&amp;running_task_list, task_to_run, state_list, task_to_run-&gt;priority);</span>

	/* If the idle task list is empty - invalidate the next time variable*/
<span style = "background-color:#fdd">	if (0U == idle_task_list.size)</span>
	{
<span style = "background-color:#fdd">		rltos_next_idle_ready_tick = RLTOS_UINT_MAX;
	}</span>
	else
	{
		/* Otherwise update it*/
<span style = "background-color:#fdd">		rltos_next_idle_ready_wrap_count = idle_task_list.p_head-&gt;idle_wrap_count;
		rltos_next_idle_ready_tick = idle_task_list.p_head-&gt;idle_ready_time;</span>
	}
<span style = "background-color:#fdd">}</span>
/* END OF FUNCTION*/

void Task_set_current_idle(const rltos_uint time_to_idle)
<span style = "background-color:#fdd">{</span>
	/* Calculate next expiration time*/
<span style = "background-color:#fdd">	p_current_task_ctl-&gt;idle_ready_time = rltos_system_tick + time_to_idle;
	p_current_task_ctl-&gt;idle_time = time_to_idle;</span>
	/* Wraparound check*/
<span style = "background-color:#fdd">	if(p_current_task_ctl-&gt;idle_ready_time &lt; rltos_system_tick)</span>
	{
<span style = "background-color:#fdd">		p_current_task_ctl-&gt;idle_wrap_count = rltos_wrap_count + 1U;
	}</span>
	else
	{
<span style = "background-color:#fdd">		p_current_task_ctl-&gt;idle_wrap_count = rltos_wrap_count;</span>
	}

	/* If list is empty - just fill parameters*/
<span style = "background-color:#fdd">	if (idle_task_list.size == 0U)</span>
	{
<span style = "background-color:#fdd">		rltos_next_idle_ready_tick = p_current_task_ctl-&gt;idle_ready_time;
		rltos_next_idle_ready_wrap_count = p_current_task_ctl-&gt;idle_wrap_count;
	}</span>
	else
	{
		/* Both value have same wrap count i.e. both expire in the same window*/
<span style = "background-color:#fdd">		if (p_current_task_ctl-&gt;idle_wrap_count == rltos_next_idle_ready_wrap_count)</span>
		{
			/* Equal wrap counts - check if computed expiration tick time is quicker */
<span style = "background-color:#fdd">			if (p_current_task_ctl-&gt;idle_ready_time &lt; rltos_next_idle_ready_tick)</span>
			{
<span style = "background-color:#fdd">				rltos_next_idle_ready_tick = p_current_task_ctl-&gt;idle_ready_time;</span>
			}
<span style = "background-color:#fdd">		}
		else if (p_current_task_ctl-&gt;idle_wrap_count &lt; rltos_next_idle_ready_wrap_count)</span>
		{
			/* computed wrap count is before the next wrap count, new one must be first*/
<span style = "background-color:#fdd">			rltos_next_idle_ready_tick = p_current_task_ctl-&gt;idle_ready_time;
			rltos_next_idle_ready_wrap_count = p_current_task_ctl-&gt;idle_wrap_count;</span>
		}
		else
		{
			/* computed wrap count it too large - cannot possibly be next in line*/
		}
	}

<span style = "background-color:#fdd">	Task_remove_from_list(&amp;running_task_list, p_current_task_ctl, state_list);
	Task_insert_in_list(&amp;idle_task_list, p_current_task_ctl, state_list, p_current_task_ctl-&gt;idle_time);</span>

	/* If we have just idled the current index task, the index has implicitly been updated - so the scheduler doesnt need to switch tasks on next run*/
<span style = "background-color:#fdd">	should_switch_task = false;
}</span>
/* END OF FUNCTION*/

void Task_set_current_wait_on_object(p_task_list_t const owner, const rltos_uint time_to_wait)
<span style = "background-color:#fdd">{</span>
	/* Idle the task until it is told to run, either by the scheduler or the owning objects signal*/
<span style = "background-color:#fdd">	Task_set_current_idle(time_to_wait);</span>

	/* Dont care about the order in which they are appended*/
<span style = "background-color:#fdd">	Task_append_to_list(owner, p_current_task_ctl, aux_list);
}</span>
/* END OF FUNCTION*/

static void Task_insert_in_list(p_task_list_t const list_for_insert, p_task_ctl_t const task_to_insert, const list_index_t list_index, const rltos_uint sorting_value)
<span style = "background-color:#dfd">{	</span>
	/* If first task*/
<span style = "background-color:#dfd">	if (0U == list_for_insert-&gt;size)</span>
	{
		/* Make entire list circular to single task*/
<span style = "background-color:#dfd">		list_for_insert-&gt;p_head = task_to_insert;
		list_for_insert-&gt;p_index = task_to_insert;
		task_to_insert-&gt;p_next_tctl[list_index] = task_to_insert;
		task_to_insert-&gt;p_prev_tctl[list_index] = task_to_insert;
	}</span>
	else
	{
		/* If the value belongs at the end of the list, append it*/ 
<span style = "background-color:#dfd">		if(sorting_value &gt;= list_for_insert-&gt;p_head-&gt;p_prev_tctl[list_index]-&gt;sorting_values[list_index])</span>
		{
<span style = "background-color:#dfd">			task_to_insert-&gt;p_prev_tctl[list_index] = list_for_insert-&gt;p_head-&gt;p_prev_tctl[list_index];
			task_to_insert-&gt;p_next_tctl[list_index] = list_for_insert-&gt;p_head;
			list_for_insert-&gt;p_head-&gt;p_prev_tctl[list_index]-&gt;p_next_tctl[list_index] = task_to_insert;
			list_for_insert-&gt;p_head-&gt;p_prev_tctl[list_index] = task_to_insert;
		}
		else if(sorting_value &lt; list_for_insert-&gt;p_head-&gt;sorting_values[list_index])</span>
		{
			/* Update the head*/
<span style = "background-color:#dfd">			task_to_insert-&gt;p_prev_tctl[list_index] = list_for_insert-&gt;p_head-&gt;p_prev_tctl[list_index];
			task_to_insert-&gt;p_next_tctl[list_index] = list_for_insert-&gt;p_head;
			list_for_insert-&gt;p_head-&gt;p_prev_tctl[list_index]-&gt;p_next_tctl[list_index] = task_to_insert;
			list_for_insert-&gt;p_head = task_to_insert;
		}</span>
		else
		{
			/* Walk the list until; we get back to head OR we get to a list entry that belongs AFTER the current entry*/
<span style = "background-color:#fdd">			p_task_ctl_t walk_value = list_for_insert-&gt;p_head-&gt;p_next_tctl[list_index];
			while( (sorting_value &gt;= walk_value-&gt;sorting_values[list_index]) &amp;&amp; (walk_value != list_for_insert-&gt;p_head) )</span>
			{
<span style = "background-color:#fdd">				walk_value = walk_value-&gt;p_next_tctl[list_index];
			}</span>
			
<span style = "background-color:#fdd">			task_to_insert-&gt;p_prev_tctl[list_index] = walk_value-&gt;p_prev_tctl[list_index];
			task_to_insert-&gt;p_next_tctl[list_index] = walk_value;
			walk_value-&gt;p_prev_tctl[list_index]-&gt;p_next_tctl[list_index] = task_to_insert;</span>
		}
	}

	/* Set the new owner list*/
<span style = "background-color:#dfd">	task_to_insert-&gt;p_owners[list_index] = list_for_insert;</span>
	/* Set the new sorting value*/
<span style = "background-color:#dfd">	task_to_insert-&gt;sorting_values[list_index] = sorting_value;</span>

	/* Increment list size*/
<span style = "background-color:#dfd">	list_for_insert-&gt;size += 1U;
}</span>
/* END OF FUNCTION*/

static void Task_append_to_list(p_task_list_t const list_for_append, p_task_ctl_t const task_to_append, const list_index_t list_index)
<span style = "background-color:#fdd">{</span>
	/* If first task*/
<span style = "background-color:#fdd">	if (0U == list_for_append-&gt;size)</span>
	{
		/* Make entire list circular to single task*/
<span style = "background-color:#fdd">		list_for_append-&gt;p_head = task_to_append;
		list_for_append-&gt;p_index = task_to_append;
		task_to_append-&gt;p_next_tctl[list_index] = task_to_append;
		task_to_append-&gt;p_prev_tctl[list_index] = task_to_append;
	}</span>
	else
	{
		/* Otherwise insert at the end of the list*/
<span style = "background-color:#fdd">		task_to_append-&gt;p_prev_tctl[list_index] = list_for_append-&gt;p_head-&gt;p_prev_tctl[list_index];
		task_to_append-&gt;p_next_tctl[list_index] = list_for_append-&gt;p_head;
		list_for_append-&gt;p_head-&gt;p_prev_tctl[list_index]-&gt;p_next_tctl[list_index] = task_to_append;
		list_for_append-&gt;p_head-&gt;p_prev_tctl[list_index] = task_to_append;</span>
	}

	/* Set the new owner list*/
<span style = "background-color:#fdd">	task_to_append-&gt;p_owners[list_index] = list_for_append;</span>

	/* Increment list size*/
<span style = "background-color:#fdd">	list_for_append-&gt;size += 1U;
}</span>
/* END OF FUNCTION*/

static void Task_remove_from_list(p_task_list_t const list_for_remove, p_task_ctl_t const task_to_remove, const list_index_t list_index)
<span style = "background-color:#dfd">{</span>
	/* Only operate on a list where the task is garuanteed to be owned by that list*/
<span style = "background-color:#dfd">	if (task_to_remove-&gt;p_owners[list_index] == list_for_remove)</span>
	{
<span style = "background-color:#dfd">		list_for_remove-&gt;size -= 1U;</span>

		/* If last task in list*/
<span style = "background-color:#dfd">		if (list_for_remove-&gt;size == 0U)</span>
		{
			/* Reset the list*/
<span style = "background-color:#dfd">			list_for_remove-&gt;p_head = NULL;
			list_for_remove-&gt;p_index = NULL;
		}</span>
		else
		{
			/* Otherwise ensure lists connections are updated*/
<span style = "background-color:#dfd">			task_to_remove-&gt;p_prev_tctl[list_index]-&gt;p_next_tctl[list_index] = task_to_remove-&gt;p_next_tctl[list_index];
			task_to_remove-&gt;p_next_tctl[list_index]-&gt;p_prev_tctl[list_index] = task_to_remove-&gt;p_prev_tctl[list_index];</span>

<span style = "background-color:#dfd">			if (list_for_remove-&gt;p_head == task_to_remove)</span>
			{
<span style = "background-color:#dfd">				list_for_remove-&gt;p_head = task_to_remove-&gt;p_next_tctl[list_index];</span>
			}

<span style = "background-color:#dfd">			if (list_for_remove-&gt;p_index == task_to_remove)</span>
			{
<span style = "background-color:#dfd">				list_for_remove-&gt;p_index = task_to_remove-&gt;p_next_tctl[list_index];</span>
			}
		}

		/* Remove list as owner*/
<span style = "background-color:#dfd">		task_to_remove-&gt;p_owners[list_index] = NULL;</span>

		/* Remove tasks next and previous entries*/
<span style = "background-color:#dfd">		task_to_remove-&gt;p_prev_tctl[list_index] = NULL;
		task_to_remove-&gt;p_next_tctl[list_index] = NULL;</span>
	}
<span style = "background-color:#dfd">}</span>
/* END OF FUNCTION*/

/** @brief implementation of rltos tick increment - called from rltos_scheduler_asm.asm */
/* cppcheck-suppress misra-c2012-8.4 - this function is externed/declared in assembly file for porting the scheduler*/
void Rltos_scheduler_tick_inc(void)
<span style = "background-color:#fdd">{</span>
	/* Increment system tick counter*/
<span style = "background-color:#fdd">	++rltos_system_tick;</span>

	/* check for wraparound*/
<span style = "background-color:#fdd">	if (rltos_system_tick == 0U)</span>
	{
<span style = "background-color:#fdd">		++rltos_wrap_count;</span>
	}

	/* While idle tasks are ready.
	* AND 
	* next idle tasks wrap counter matches system wrap counter.
	* AND 
	* system tick count has expired the next idles tasks expiry time.
	*/
	while ((idle_task_list.size &gt; 0U) &amp;&amp;
<span style = "background-color:#fdd">		   (rltos_wrap_count == rltos_next_idle_ready_wrap_count) &amp;&amp;</span>
		   (rltos_system_tick &gt;= rltos_next_idle_ready_tick))
	{
		/* Head of list is always first, list is ordered such that the next expiration time is at the head
		* Function also updates the system parameters rltos_next_idle_ready_wrap_count and rltos_next_idle_ready_tick
		*/
<span style = "background-color:#fdd">		Task_set_running(idle_task_list.p_head);
	}
}</span>

/** @brief implementation of rltos context switch - called from rltos_scheduler_asm.asm */
/* cppcheck-suppress misra-c2012-8.4 - this function is externed/declared in assembly file for porting the scheduler*/
void Rltos_scheduler_switch_context(void)
<span style = "background-color:#fdd">{</span>
	/* If we need to switch task - do so, otherwise mark as needing to switch next time*/
<span style = "background-color:#fdd">	if (should_switch_task)</span>
	{
<span style = "background-color:#fdd">		running_task_list.p_index = running_task_list.p_index-&gt;p_next_tctl[state_list];
	}</span>
	else
	{
<span style = "background-color:#fdd">		should_switch_task = true;</span>
	}

<span style = "background-color:#fdd">	p_current_task_ctl = running_task_list.p_index;
}</span>
/* END OF FUNCTION*/

/*! @} */</pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>