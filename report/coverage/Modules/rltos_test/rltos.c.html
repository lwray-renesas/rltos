<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>rltos.c</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
/**
 * @addtogroup Rltos_task_prv prv
 * The private data (implementation) of the RLTOS kernels tasks.
 * @ingroup Rltos_task
 * @{
 */

#include "rltos.h"
#include "task_list/rltos_task_list.h"

/** @brief Function to enter the first rltos task.
 * @details Defined in rltos_kernel.asm - does not save context, only restores it and returns as though from interrupt (RETI).
 * This function MUST be called after initialising the current task pointer (p_current_task_ctl).
 */
extern void Rltos_enter_first_task(void);

/** @brief Initialises stack for creation of task.
 * This function is provided by the porting layer.
 * @return The value of the stack pointer post initialisation (used to restore context).
*/
extern stack_ptr_type Rltos_stack_init(stack_ptr_type p_stack_top, void (*const p_task_func)(void));

/** @brief Initialises and start RLTOS tick timer.
 * This function is provided by the application layer.
*/
extern void Rltos_start_tick_timer(void);

void Rltos_kernel_enter(void)
<span style = "background-color:#fdd">{
	Scheduler_init();
	Rltos_start_tick_timer();
	Rltos_enter_first_task();
}</span>
/* END OF FUNCTION*/

void Rltos_task_create(p_dummy_task_t const task_to_add, stack_ptr_type const p_stack_top, void (*const p_task_func)(void), rltos_uint task_priority, bool run_task)
<span style = "background-color:#fdd">{</span>
	/* Initialise the stack*/
<span style = "background-color:#fdd">	stack_ptr_type l_p_stack_top = Rltos_stack_init(p_stack_top, p_task_func);</span>

	/* Initialise the task*/
	/* cppcheck-suppress misra-c2012-11.3 - dummy task type MUST be used for static allocation. Size of dummy types are always tested to be equal (on each platform) to the casted real types*/
<span style = "background-color:#fdd">	Task_init((p_task_ctl_t)(task_to_add), l_p_stack_top, p_task_func, task_priority, run_task);
}</span>
/* END OF FUNCTION*/

void Rltos_task_sleep(const rltos_uint tick_count)
<span style = "background-color:#fdd">{
	if (tick_count &gt; 0U)</span>
	{
		/* Idle the current task*/
<span style = "background-color:#fdd">		Task_set_current_idle(tick_count);</span>

		/* Force yield the task*/
		Rltos_task_yield();
	}
<span style = "background-color:#fdd">}</span>
/* END OF FUNCTION*/

/*! @} */</pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>